package main

import (
	"fmt"
	"html/template"
	"log"
	"math/rand"
	"net/http"
	"regexp"
	"sort"
	"strconv"
	"strings"
	"time"
	"unicode"
)

// ===================================================================================
// DATA & MAPS
// ===================================================================================

var primaryCharMap = map[string]string{
	"\n\n": "\n\n‚Ç™", "oro": "üñ∏", "nn": "ùáö", "ch": "gl", "ll": "jh", "oy": "o√Ω", "rr": "j", "cu": "q‚èù", "qu": "k√∞", "ss": "‚Ç∑", "ah": "‚ç∫", "a": "o", "b": "v",
	"c": "k", "d": "t", "e": "u", "f": "‚à´", "g": "j", "h": "p", "i": "a", "√≠": "‚üë",
	"j": "y", "k": "s", "l": "r", "m": "n", "n": "m", "√±": "‚†àny", "o": "i",
	"p": "b", "q": "k‚èù", "r": "s", "s": "z", "t": "d", "u": "√µ", "√∫": "¬µ", "v": "w",
	"w": "¬≠", "x": "‚òà", "y": "√Ω", "z": "x",
}

var unpronounceableMap = map[string]string{
	"zŒ∏s": "Œ∏z", "pny": "ny",
}

// ===================================================================================
// UI TEMPLATE
// ===================================================================================

const htmlTemplate = `
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Pejelagarto Translator</title>
    <style>
        body { font-family: sans-serif; background-color: #f0f2f5; margin: 0; padding: 20px; display: flex; justify-content: center; }
        .container { background-color: #ffffff; padding: 30px; border-radius: 8px; box-shadow: 0 4px 8px rgba(0,0,0,0.1); width: 100%; max-width: 900px; }
        h1 { color: #333; text-align: center; }
        textarea { width: 100%; height: 200px; margin-top: 10px; padding: 10px; border: 1px solid #ccc; border-radius: 4px; box-sizing: border-box; font-size: 16px; }
        .buttons { text-align: center; margin-top: 20px; }
        button { background-color: #007bff; color: white; padding: 12px 20px; border: none; border-radius: 4px; cursor: pointer; font-size: 16px; margin: 0 10px; }
        button:hover { background-color: #0056b3; }
        label { font-weight: bold; color: #555; }
    </style>
</head>
<body>
    <div class="container">
        <h1>Pejelagarto Translator</h1>
        <form action="/translate" method="post">
            <label for="input_text">Your Text:</label>
            <textarea id="input_text" name="input_text">{{.Input}}</textarea>
            
            <div class="buttons">
                <button type="submit" name="direction" value="to">Translate to Pejelagarto &raquo;</button>
                <button type="submit" name="direction" value="from">&laquo; Translate from Pejelagarto</button>
            </div>

            <label for="output_text">Result:</label>
            <textarea id="output_text" name="output_text" readonly>{{.Output}}</textarea>
        </form>
    </div>
</body>
</html>
`

var tmpl = template.Must(template.New("translator").Parse(htmlTemplate))

type TemplateData struct {
	Input  string
	Output string
}

// ===================================================================================
// API SIMULATION
// ===================================================================================

func GetWorldTemperatureIncreased(r *rand.Rand) (bool, bool) {
	if r.Intn(10) == 0 {
		return false, false
	}
	return r.Intn(2) == 0, true
}
func GetBitcoinPriceIncreased(r *rand.Rand) (bool, bool) {
	if r.Intn(10) == 0 {
		return false, false
	}
	return r.Intn(2) == 1, true
}
func IsReligiousHoliday(r *rand.Rand) (bool, bool) {
	if r.Intn(10) == 0 {
		return false, false
	}
	return r.Intn(20) == 0, true
}
func GetExtinctSpeciesCount(r *rand.Rand) (int, bool) {
	if r.Intn(10) == 0 {
		return 0, false
	}
	return 5000 + r.Intn(1000), true
}
func GetYearsSinceLastPopeDeath(r *rand.Rand) (int, bool) {
	if r.Intn(10) == 0 {
		return 0, false
	}
	return time.Now().UTC().Year() - 2022, true
}

// ===================================================================================
// ENCODING MARK LOGIC
// ===================================================================================

type EncodingMarkData struct {
	TimeIsRAK                bool
	TempIncreased            string // NEE, WKO, DHAR
	BitcoinIncreased         string // BIT, GBI, ZKU
	IsHoliday                string // RRA, NUM, SKU
	ExtinctSpeciesCount      int    // -1 for unknown
	PopeRuleApplied          bool
	AlphanumDivisibleBy3     bool
	AlphanumDivisibleBy2And5 bool
}

func boolToFlag(b bool) string {
	if b {
		return "I"
	}
	return "O"
}

func (e *EncodingMarkData) Generate() string {
	var sb strings.Builder
	if e.TimeIsRAK {
		sb.WriteString("RAK")
	} else {
		sb.WriteString("UMH")
	}
	sb.WriteString(e.TempIncreased)
	sb.WriteString(e.BitcoinIncreased)
	sb.WriteString(e.IsHoliday)
	sb.WriteString(boolToFlag(e.PopeRuleApplied))
	sb.WriteString(boolToFlag(e.AlphanumDivisibleBy3))
	sb.WriteString(boolToFlag(e.AlphanumDivisibleBy2And5))
	if e.ExtinctSpeciesCount == -1 {
		sb.WriteString("EXAXA")
	} else {
		sb.WriteString(strconv.Itoa(e.ExtinctSpeciesCount))
	}
	return sb.String()
}

func ParseEncodingMark(mark string) (EncodingMarkData, error) {
	data := EncodingMarkData{}
	if len(mark) < 15 {
		return data, fmt.Errorf("invalid encoding mark: too short")
	}

	codesPart := mark[:12]
	data.TimeIsRAK = codesPart[0:3] == "RAK"
	data.TempIncreased = codesPart[3:6]
	data.BitcoinIncreased = codesPart[6:9]
	data.IsHoliday = codesPart[9:12]

	flagsPart := mark[12:15]
	data.PopeRuleApplied = flagsPart[0] == 'I'
	data.AlphanumDivisibleBy3 = flagsPart[1] == 'I'
	data.AlphanumDivisibleBy2And5 = flagsPart[2] == 'I'

	numberPart := mark[15:]
	if numberPart == "EXAXA" {
		data.ExtinctSpeciesCount = -1
	} else {
		count, err := strconv.Atoi(numberPart)
		if err != nil {
			return data, fmt.Errorf("invalid extinct species count in mark: %v", err)
		}
		data.ExtinctSpeciesCount = count
	}
	return data, nil
}

// ===================================================================================
// TRANSLATE TO PEJELAGARTO
// ===================================================================================

func TranslateToPejelagarto(text string) (string, error) {
	r := rand.New(rand.NewSource(1))

	encoding := EncodingMarkData{}
	now := time.Now().UTC()

	encoding.TimeIsRAK = now.Hour() >= 12
	tempIncreased, tempSuccess := GetWorldTemperatureIncreased(r)
	if !tempSuccess {
		encoding.TempIncreased = "DHAR"
	} else if tempIncreased {
		encoding.TempIncreased = "NEE"
	} else {
		encoding.TempIncreased = "WKO"
	}
	btcIncreased, btcSuccess := GetBitcoinPriceIncreased(r)
	if !btcSuccess {
		encoding.BitcoinIncreased = "ZKU"
	} else if btcIncreased {
		encoding.BitcoinIncreased = "BIT"
	} else {
		encoding.BitcoinIncreased = "GBI"
	}
	isHoliday, holidaySuccess := IsReligiousHoliday(r)
	if !holidaySuccess {
		encoding.IsHoliday = "SKU"
	} else if isHoliday {
		encoding.IsHoliday = "RRA"
	} else {
		encoding.IsHoliday = "NUM"
	}
	extinctCount, extinctSuccess := GetExtinctSpeciesCount(r)
	if !extinctSuccess {
		encoding.ExtinctSpeciesCount = -1
	} else {
		encoding.ExtinctSpeciesCount = extinctCount
	}
	years, popeSuccess := GetYearsSinceLastPopeDeath(r)
	encoding.PopeRuleApplied = popeSuccess && years >= 5
	alphanumCount := 0
	for _, c := range text {
		if unicode.IsLetter(c) || unicode.IsNumber(c) {
			alphanumCount++
		}
	}
	encoding.AlphanumDivisibleBy3 = alphanumCount%3 == 0
	encoding.AlphanumDivisibleBy2And5 = alphanumCount%2 == 0 && alphanumCount%5 == 0

	protected := make(map[string]string)
	protect := func(s string) string {
		placeholder := fmt.Sprintf("{{PROTECTED_%d}}", len(protected))
		protected[placeholder] = s
		return placeholder
	}
	reUrl := regexp.MustCompile(`https?://\S+`)
	text = reUrl.ReplaceAllStringFunc(text, protect)
	reEmail := regexp.MustCompile(`\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b`)
	text = reEmail.ReplaceAllStringFunc(text, protect)
	reNum := regexp.MustCompile(`\b\d+\b`)
	text = reNum.ReplaceAllStringFunc(text, protect)

	if len(text) >= 5 {
		var sb strings.Builder
		runes := []rune(text)
		for i := 0; i < len(runes); {
			if i+4 < len(runes) && unicode.IsLetter(runes[i]) && unicode.IsLetter(runes[i+1]) &&
				runes[i+1] == runes[i]+1 && runes[i+2] == runes[i+1]+1 &&
				runes[i+3] == runes[i+2]+1 && runes[i+4] == runes[i+3]+1 {
				for j := 0; j < 5; j++ {
					sb.WriteString(fmt.Sprintf("0x%x", runes[i+j]))
				}
				i += 5
			} else {
				sb.WriteRune(runes[i])
				i++
			}
		}
		text = sb.String()
	}

	var sb strings.Builder
	for _, c := range text {
		if unicode.IsUpper(c) {
			lower := unicode.ToLower(c)
			sb.WriteRune(lower)
			sb.WriteRune(lower)
		} else {
			sb.WriteRune(c)
		}
	}
	text = sb.String()

	// *** FIX ***: Use the new robust mapping function.
	text = applyMapWithTagging(text, primaryCharMap)

	text = strings.ReplaceAll(text, "¬°", "")
	text = strings.ReplaceAll(text, "!", "√ó")
	sentenceRegex := regexp.MustCompile(`[^.!?\n]+[.!?\n]?`)
	text = sentenceRegex.ReplaceAllStringFunc(text, func(s string) string {
		if strings.Contains(s, "?") && !strings.Contains(s, "¬ø") {
			return "¬ø" + s
		}
		return s
	})
	text = strings.ReplaceAll(text, "(", "{")
	text = strings.ReplaceAll(text, ")", "}")
	text = strings.ReplaceAll(text, "[", "‚éù")
	text = strings.ReplaceAll(text, "]", "‚éû")

	phraseRegex := regexp.MustCompile(`(^|\.|:|
)\s*p`)
	text = phraseRegex.ReplaceAllString(text, "${1}`p")

	text = applyPrimeProperty(text, 'o', '√¢', false)
	text = applyPrimeProperty(text, 'u', '√™', true)

	text = applyIndexedModification(text, 'n', "nh", encoding.TimeIsRAK)
	switch encoding.TempIncreased {
	case "NEE":
		text = applyNthModification(text, 'n', "nn", 4)
	case "WKO":
		text = applyNthModification(text, 'm', "mm", 4)
	case "DHAR":
		text = applyNthModification(text, 's', "ss", 4)
	}
	switch encoding.BitcoinIncreased {
	case "BIT":
		text = replaceFirstAndLast(text, "v", "$")
	case "GBI":
		text = replaceFirstAndLast(text, "$", "v")
	case "ZKU":
		text = strings.NewReplacer("up", "dw", "dw", "up").Replace(text)
	}
	switch encoding.IsHoliday {
	case "RRA":
		text = strings.NewReplacer("god", "dog", "dog", "god").Replace(text)
	case "SKU":
		text = strings.NewReplacer("the", "ate", "ate", "the").Replace(text)
	}
	if encoding.PopeRuleApplied {
		text = strings.NewReplacer("pez", "cuis", "cuis", "pez").Replace(text)
	}

	day := now.Day()
	if day > 0 {
		var cappedText strings.Builder
		for i, c := range text {
			if i > 0 && i%day == 0 {
				cappedText.WriteRune(unicode.ToUpper(c))
			} else {
				cappedText.WriteRune(c)
			}
		}
		text = cappedText.String()
	}

	if encoding.ExtinctSpeciesCount > 0 {
		var tildedText strings.Builder
		vowels, tildeMap := "aeiou", map[rune]rune{'a': '√°', 'e': '√©', 'i': '√≠', 'o': '√≥', 'u': '√∫'}
		for i, c := range text {
			if i > 0 && i%encoding.ExtinctSpeciesCount == 0 && strings.ContainsRune(vowels, unicode.ToLower(c)) {
				if tilde, ok := tildeMap[unicode.ToLower(c)]; ok {
					tildedText.WriteRune(tilde)
				} else {
					tildedText.WriteRune(c)
				}
			} else {
				tildedText.WriteRune(c)
			}
		}
		text = tildedText.String()
	}

	// *** FIX ***: Use the new robust mapping function here as well.
	text = applyMapWithTagging(text, unpronounceableMap)

	for placeholder, original := range protected {
		text = strings.ReplaceAll(text, placeholder, original)
	}

	return encoding.Generate() + "\n" + text, nil
}

// ===================================================================================
// TRANSLATE FROM PEJELAGARTO
// ===================================================================================

var newlineRegex = regexp.MustCompile(`\r?\n`)

func TranslateFromPejelagarto(pejelagartoText string) (string, error) {
	parts := newlineRegex.Split(pejelagartoText, 2)
	if len(parts) < 2 {
		return "", fmt.Errorf("invalid format: missing encoding mark")
	}
	encodingMark, text := parts[0], parts[1]

	encoding, err := ParseEncodingMark(encodingMark)
	if err != nil {
		return "", fmt.Errorf("could not parse encoding mark: %v", err)
	}

	// *** FIX: Apply reverse mapping BEFORE emoji removal ***
	reversePrimaryMap := getReverseMultiMap(primaryCharMap)
	text = applyReverseMapWithTagging(text, reversePrimaryMap)

	reEmoji := regexp.MustCompile(`[\p{So}]`)
	text = reEmoji.ReplaceAllString(text, "")
	text = strings.NewReplacer(
		"..", ".", ",,", ",", "‚Äô", ",", "‚Äò", ",", "√ó", "!", "{", "(", "}", ")", "‚éù", "[", "‚éû", "]", "`p", "p",
		"√¢", "o", "√™", "u", "√°", "a", "√©", "e", "√≠", "i", "√≥", "o", "√∫", "u", "√µ", "u",
		"√Å", "A", "√â", "E", "√ç", "I", "√ì", "O", "√ö", "U",
	).Replace(text)
	//text = strings.ReplaceAll(text, "[", "‚éù")
	//text = strings.ReplaceAll(text, "]", "‚éû")

	switch encoding.BitcoinIncreased {
	case "BIT":
		text = replaceFirstAndLast(text, "$", "v")
	case "GBI":
		text = replaceFirstAndLast(text, "v", "$")
	case "ZKU":
		text = strings.NewReplacer("up", "dw", "dw", "up").Replace(text)
	}
	switch encoding.IsHoliday {
	case "RRA":
		text = strings.NewReplacer("god", "dog", "dog", "god").Replace(text)
	case "SKU":
		text = strings.NewReplacer("the", "ate", "ate", "the").Replace(text)
	}
	if encoding.PopeRuleApplied {
		text = strings.NewReplacer("pez", "cuis", "cuis", "pez").Replace(text)
	}

	reHex := regexp.MustCompile(`(0x[0-9a-fA-F]{2})+`)
	text = reHex.ReplaceAllStringFunc(text, func(s string) string {
		hexParts := strings.Split(s, "0x")[1:]
		var asciiStr strings.Builder
		for _, hp := range hexParts {
			val, _ := strconv.ParseInt(hp, 16, 32)
			asciiStr.WriteRune(rune(val))
		}
		return asciiStr.String()
	})

	text = strings.ToLower(text)
	var capitalizedText strings.Builder
	capitalizeNext := true
	for _, c := range text {
		if capitalizeNext && unicode.IsLetter(c) {
			capitalizedText.WriteRune(unicode.ToUpper(c))
			capitalizeNext = false
		} else {
			capitalizedText.WriteRune(c)
		}
		if c == '.' || c == '?' || c == '!' {
			capitalizeNext = true
		}
	}
	return capitalizedText.String(), nil
}

// ===================================================================================
// HELPER FUNCTIONS (WITH NEW MAPPING FUNCTION)
// ===================================================================================

// *** NEW FUNCTION ***
// applyMapWithTagging performs a single, non-recursive pass over the text for a given map.
// It uses temporary tags to prevent translated text from being re-translated.

// Forward mapping (unchanged)
func applyMapWithTagging(text string, replacementMap map[string]string) string {
	tag := "<alreadyTranslated>"
	endTag := "</alreadyTranslated>"

	var result strings.Builder
	sortedKeys := getSortedKeys(replacementMap)

	i := 0
	for i < len(text) {
		matched := false
		for _, key := range sortedKeys {
			if strings.HasPrefix(text[i:], key) {
				result.WriteString(tag)
				result.WriteString(replacementMap[key])
				result.WriteString(endTag)
				i += len(key)
				matched = true
				break
			}
		}
		if !matched {
			result.WriteByte(text[i])
			i++
		}
	}
	taggedText := result.String()
	cleanText := strings.ReplaceAll(taggedText, tag, "")
	cleanText = strings.ReplaceAll(cleanText, endTag, "")
	return cleanText
}

// Reverse mapping (supports multiple keys per value)
func applyReverseMapWithTagging(text string, reverseMap map[string][]string) string {
	tag := "<alreadyTranslated>"
	endTag := "</alreadyTranslated>"

	// Sort values by length descending (for multi-char replacements)
	values := make([]string, 0, len(reverseMap))
	for v := range reverseMap {
		values = append(values, v)
	}
	sort.Slice(values, func(i, j int) bool { return len(values[i]) > len(values[j]) })

	var result strings.Builder
	i := 0
	for i < len(text) {
		matched := false
		for _, val := range values {
			if strings.HasPrefix(text[i:], val) {
				// For this value, pick the longest possible original key
				keys := reverseMap[val]
				sort.Slice(keys, func(i, j int) bool { return len(keys[i]) > len(keys[j]) })
				// Use the first (longest) key
				result.WriteString(tag)
				result.WriteString(keys[0])
				result.WriteString(endTag)
				i += len(val)
				matched = true
				break
			}
		}
		if !matched {
			result.WriteByte(text[i])
			i++
		}
	}
	taggedText := result.String()
	cleanText := strings.ReplaceAll(taggedText, tag, "")
	cleanText = strings.ReplaceAll(cleanText, endTag, "")
	return cleanText
}

func getSortedKeys(m map[string]string) []string {
	keys := make([]string, 0, len(m))
	for k := range m {
		keys = append(keys, k)
	}
	sort.Slice(keys, func(i, j int) bool { return len(keys[i]) > len(keys[j]) })
	return keys
}

// New: reverse map supporting multiple keys per value
func getReverseMultiMap(m map[string]string) map[string][]string {
	reversed := make(map[string][]string)
	for k, v := range m {
		if v != "" {
			reversed[v] = append(reversed[v], k)
		}
	}
	return reversed
}

func isPrime(n int) bool {
	if n <= 1 {
		return false
	}
	for i := 2; i*i <= n; i++ {
		if n%i == 0 {
			return false
		}
	}
	return true
}

func applyPrimeProperty(text string, charToFind, charToReplace rune, fromEnd bool) string {
	var indices []int
	runes := []rune(text)
	for i, r := range runes {
		if r == charToFind {
			indices = append(indices, i)
		}
	}
	if fromEnd {
		for i, j := 0, len(indices)-1; i < j; i, j = i+1, j-1 {
			indices[i], indices[j] = indices[j], indices[i]
		}
	}
	for i, originalIndex := range indices {
		if isPrime(i) {
			runes[originalIndex] = charToReplace
		}
	}
	return string(runes)
}

func applyIndexedModification(text string, charToFind rune, replacement string, odd bool) string {
	var sb strings.Builder
	count := 0
	for _, r := range text {
		if r == charToFind {
			if (odd && count%2 != 0) || (!odd && count%2 == 0) {
				sb.WriteString(replacement)
			} else {
				sb.WriteRune(r)
			}
			count++
		} else {
			sb.WriteRune(r)
		}
	}
	return sb.String()
}

func applyNthModification(text string, charToFind rune, replacement string, n int) string {
	var sb strings.Builder
	count := 0
	for _, r := range text {
		if r == charToFind {
			count++
			if count > 0 && count%n == 0 {
				sb.WriteString(replacement)
			} else {
				sb.WriteRune(r)
			}
		} else {
			sb.WriteRune(r)
		}
	}
	return sb.String()
}

func replaceFirstAndLast(s, old, new string) string {
	first := strings.Index(s, old)
	if first == -1 {
		return s
	}
	s = s[:first] + new + s[first+len(old):]
	last := strings.LastIndex(s, old)
	if last != -1 {
		s = s[:last] + new + s[last+len(old):]
	}
	return s
}

// ===================================================================================
// WEB SERVER & MAIN FUNCTION
// ===================================================================================

func rootHandler(w http.ResponseWriter, r *http.Request) {
	if r.URL.Path != "/" {
		http.NotFound(w, r)
		return
	}
	tmpl.Execute(w, TemplateData{Input: "", Output: ""})
}

func translateHandler(w http.ResponseWriter, r *http.Request) {
	if r.Method != http.MethodPost {
		http.Redirect(w, r, "/", http.StatusSeeOther)
		return
	}
	inputText := r.FormValue("input_text")
	direction := r.FormValue("direction")
	var outputText string
	var err error

	if direction == "to" {
		outputText, err = TranslateToPejelagarto(inputText)
	} else if direction == "from" {
		outputText, err = TranslateFromPejelagarto(inputText)
	} else {
		err = fmt.Errorf("invalid translation direction")
	}

	if err != nil {
		outputText = "ERROR: " + err.Error()
	}
	tmpl.Execute(w, TemplateData{Input: inputText, Output: outputText})
}

func main() {
	http.HandleFunc("/", rootHandler)
	http.HandleFunc("/translate", translateHandler)
	fmt.Println("Starting Pejelagarto Translator UI...")
	fmt.Println("Access it at http://localhost:8080")
	err := http.ListenAndServe(":8080", nil)
	if err != nil {
		log.Fatalf("Failed to start server: %v", err)
	}
}
